


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AdminController</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">Green_trade.green_trade_platform.controller</a>
</div>

<h1>Coverage Summary for Class: AdminController (Green_trade.green_trade_platform.controller)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AdminController</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/71)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package Green_trade.green_trade_platform.controller;
&nbsp;
&nbsp;import Green_trade.green_trade_platform.mapper.AdminMapper;
&nbsp;import Green_trade.green_trade_platform.mapper.PostProductListMapper;
&nbsp;import Green_trade.green_trade_platform.mapper.PostProductMapper;
&nbsp;import Green_trade.green_trade_platform.mapper.ResponseMapper;
&nbsp;import Green_trade.green_trade_platform.model.*;
&nbsp;import Green_trade.green_trade_platform.request.ApproveSellerRequest;
&nbsp;import Green_trade.green_trade_platform.request.CreateAdminRequest;
&nbsp;import Green_trade.green_trade_platform.request.NeedVerifyPostRequest;
&nbsp;import Green_trade.green_trade_platform.request.PostProductDecisionRequest;
&nbsp;import Green_trade.green_trade_platform.response.*;
&nbsp;import Green_trade.green_trade_platform.service.implement.AdminServiceImpl;
&nbsp;import Green_trade.green_trade_platform.service.implement.BuyerServiceImpl;
&nbsp;import Green_trade.green_trade_platform.service.implement.PostProductServiceImpl;
&nbsp;import Green_trade.green_trade_platform.service.implement.SellerServiceImpl;
&nbsp;import com.fasterxml.jackson.core.JsonProcessingException;
&nbsp;import io.swagger.v3.oas.annotations.Operation;
&nbsp;import jakarta.validation.Valid;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.data.domain.Page;
&nbsp;import org.springframework.http.HttpStatus;
&nbsp;import org.springframework.http.ResponseEntity;
&nbsp;import org.springframework.security.access.prepost.PreAuthorize;
&nbsp;import org.springframework.web.bind.annotation.*;
&nbsp;import org.springframework.web.multipart.MultipartFile;
&nbsp;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;@RestController
&nbsp;@RequestMapping(&quot;/api/v1/admin&quot;)
&nbsp;@RequiredArgsConstructor
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class AdminController {
&nbsp;    private final SellerServiceImpl sellerService;
&nbsp;    private final PostProductServiceImpl postProductServiceImpl;
&nbsp;    private final ResponseMapper responseMapper;
&nbsp;    private final AdminServiceImpl adminService;
&nbsp;    private final AdminMapper adminMapper;
&nbsp;    private final PostProductMapper postProductMapper;
&nbsp;    private final PostProductListMapper postProductListMapper;
&nbsp;    private final NotificationSocketController socketController;
&nbsp;    private final BuyerServiceImpl buyerService;
&nbsp;
&nbsp;    @Operation(
&nbsp;            summary = &quot;Get all pending seller accounts&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                        Retrieves a paginated list of seller accounts that are currently in a pending verification or approval state.
&nbsp;                        This endpoint is restricted to administrators only (requires ROLE_ADMIN authority).
&nbsp;                    
&nbsp;                        The API supports pagination using the &#39;page&#39; and &#39;size&#39; query parameters.
&nbsp;                    
&nbsp;                        Response includes:
&nbsp;                        - A list of sellers awaiting approval (`sellers`)
&nbsp;                        - Pagination details such as current page, total elements, and total pages
&nbsp;                    
&nbsp;                        Typical use cases:
&nbsp;                        - Admin dashboard for managing seller approvals
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @GetMapping(&quot;/pending-seller&quot;)
&nbsp;    public ResponseEntity&lt;?&gt; findAllPendingSeller(
&nbsp;            @RequestParam(defaultValue = &quot;0&quot;) int page,
&nbsp;            @RequestParam(defaultValue = &quot;10&quot;) int size
&nbsp;    ) {
<b class="nc">&nbsp;        Page&lt;SellerResponse&gt; ans = sellerService.getAllPendingSeller(page, size);</b>
<b class="nc">&nbsp;        Map&lt;String, Object&gt; body = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        body.put(&quot;sellers&quot;, ans.getContent());</b>
<b class="nc">&nbsp;        body.put(&quot;currentPage&quot;, ans.getNumber());</b>
<b class="nc">&nbsp;        body.put(&quot;totalElements&quot;, ans.getTotalElements());</b>
<b class="nc">&nbsp;        body.put(&quot;totalPage&quot;, ans.getTotalPages());</b>
&nbsp;
<b class="nc">&nbsp;        return ResponseEntity.ok(body);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(
&nbsp;            summary = &quot;Approve or reject a pending seller account&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                        Handles the approval or rejection process for a pending seller registration request. 
&nbsp;                        This endpoint is restricted to administrators and requires a valid bearer token.
&nbsp;                    
&nbsp;                        The request body should contain seller information along with an approval decision. 
&nbsp;                        If approved, the seller&#39;s account status is updated and a notification is sent to the user 
&nbsp;                        in real time via WebSocket.
&nbsp;                    
&nbsp;                        **Workflow:**
&nbsp;                        1. Admin submits approval/rejection data through this endpoint.
&nbsp;                        2. The system updates the seller’s status.
&nbsp;                        3. A notification is constructed and timestamped (`sendAt`).
&nbsp;                        4. The notification is sent to the corresponding seller user through a socket event.
&nbsp;                    
&nbsp;                        **Use cases:**
&nbsp;                        - Approving verified sellers after document validation.
&nbsp;                        - Rejecting invalid or incomplete seller registration requests.
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @PostMapping(&quot;/approve-seller&quot;)
&nbsp;    public ResponseEntity&lt;RestResponse&lt;?, ?&gt;&gt; handlePendingSeller(@RequestBody ApproveSellerRequest request) throws JsonProcessingException {
<b class="nc">&nbsp;        ApproveSellerResponse sellerNotification = sellerService.handlePendingSeller(request);</b>
<b class="nc">&nbsp;        sellerNotification.getNotification().setSendAt(LocalDateTime.now());</b>
<b class="nc">&nbsp;        socketController.sendUpgradeNotificationToUser(sellerNotification);</b>
<b class="nc">&nbsp;        return ResponseEntity.ok(responseMapper.toDto(true,</b>
&nbsp;                &quot;Approve request was be solved.&quot;,
&nbsp;                sellerNotification, null));
&nbsp;    }
&nbsp;
&nbsp;    @Operation(
&nbsp;            summary = &quot;Create a new admin account&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                        Allows an existing administrator to create a new admin account in the system.
&nbsp;                        This endpoint accepts both form data and a profile image file (`avatar_url`) for the new admin.
&nbsp;                    
&nbsp;                        The request must include valid admin details (username, email, password, role, etc.) 
&nbsp;                        and an avatar image. The uploaded avatar will be processed and linked to the new account.
&nbsp;                    
&nbsp;                        **Workflow:**
&nbsp;                        1. Admin submits a multipart/form-data request containing admin details and an avatar image.
&nbsp;                        2. The system validates the request and saves the image.
&nbsp;                        3. The new admin account is created and persisted in the database.
&nbsp;                        4. A success response is returned with the created admin&#39;s information.
&nbsp;                    
&nbsp;                        **Use cases:**
&nbsp;                        - Registering additional admin users for system management.
&nbsp;                        - Managing multi-admin access in the platform.
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @PostMapping(&quot;creating-admin&quot;)
&nbsp;    public ResponseEntity&lt;?&gt; handleCreatingAdmin(
&nbsp;            @Valid @ModelAttribute CreateAdminRequest request,
&nbsp;            @RequestPart(value = &quot;avatar_url&quot;, required = true) MultipartFile avatarFile
&nbsp;    ) {
&nbsp;        try {
<b class="nc">&nbsp;            Admin data = adminService.handleCreateAdminAccount(avatarFile, request);</b>
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(true,</b>
&nbsp;                    &quot;Create admin account successfully.&quot;,
<b class="nc">&nbsp;                    adminMapper.toDto(data),</b>
&nbsp;                    null));
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(false,</b>
&nbsp;                    &quot;Create admin account failed.&quot;,
&nbsp;                    null,
&nbsp;                    e));
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Operation(
&nbsp;            summary = &quot;Review Post Product List (Admin Only)&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                        Retrieves a paginated list of post products that are pending verification or review by administrators.  
&nbsp;                        This API is restricted to users with the `ROLE_ADMIN` authority.
&nbsp;                    
&nbsp;                        **Workflow:**
&nbsp;                        1. The admin calls this endpoint with pagination parameters (`page`, `size`).
&nbsp;                        2. The system queries all post products that are awaiting verification or moderation.
&nbsp;                        3. The endpoint returns a paginated response containing post details, along with metadata.
&nbsp;                    
&nbsp;                        **Use cases:**
&nbsp;                        - Admins reviewing newly submitted product posts before approval.
&nbsp;                        - Moderators checking flagged or edited posts that require re-verification.
&nbsp;                        - Ensuring quality control and compliance of product listings before publication.
&nbsp;                    
&nbsp;                        **Security Notes:**
&nbsp;                        - Requires JWT authentication with `ROLE_ADMIN`.
&nbsp;                        - Unauthorized users (buyers/sellers) will be denied access.
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @GetMapping(&quot;/review-post-seller-list&quot;)
&nbsp;    public ResponseEntity&lt;RestResponse&lt;PostProductListResponse, Object&gt;&gt; getAllPostProductForReview(
&nbsp;            @RequestParam(name = &quot;size&quot;, defaultValue = &quot;10&quot;) int size,
&nbsp;            @RequestParam(name = &quot;page&quot;, defaultValue = &quot;0&quot;) int page
&nbsp;    ) throws Exception {
<b class="nc">&nbsp;        log.info(&quot;&gt;&gt;&gt; Server came getAllPostProductForReview API&quot;);</b>
<b class="nc">&nbsp;        Page&lt;PostProduct&gt; postProducts = postProductServiceImpl.getAllPostProductForVerifiedReview(size, page);</b>
<b class="nc">&nbsp;        log.info(&quot;&gt;&gt;&gt; Server ran postProductServiceImpl.getAllPostProduct()&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        Map&lt;String, Object&gt; meta = Map.of(</b>
<b class="nc">&nbsp;                &quot;currentPage&quot;, postProducts.getNumber(),</b>
<b class="nc">&nbsp;                &quot;totalElements&quot;, postProducts.getTotalElements(),</b>
<b class="nc">&nbsp;                &quot;totalPage&quot;, postProducts.getTotalPages()</b>
&nbsp;        );
&nbsp;
<b class="nc">&nbsp;        PostProductListResponse responseData = postProductListMapper.toDto(postProducts.getContent(), meta);</b>
&nbsp;
<b class="nc">&nbsp;        RestResponse&lt;PostProductListResponse, Object&gt; response = responseMapper.toDto(</b>
&nbsp;                true,
&nbsp;                &quot;POST PRODUCT LIST&quot;,
&nbsp;                responseData,
&nbsp;                null
&nbsp;        );
&nbsp;
<b class="nc">&nbsp;        return ResponseEntity.status(HttpStatus.OK.value()).body(response);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;hasAnyRole(&#39;ROLE_BUYER&#39;, &#39;ROLE_SELLER&#39;, &#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @Operation(
&nbsp;            summary = &quot;View post product details by ID&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                        Retrieves detailed information for a specific post product based on its unique ID.  
&nbsp;                        Accessible to **Buyers**, **Sellers**, and **Admins** with appropriate privileges.
&nbsp;                    
&nbsp;                        **Workflow:**
&nbsp;                        1. The client sends a request containing the post product ID as a path variable.
&nbsp;                        2. The system retrieves the corresponding post product record from the database.
&nbsp;                        3. The product details are returned as a structured response, including product info, seller data, and review status.
&nbsp;                    
&nbsp;                        **Use cases:**
&nbsp;                        - **Admin:** Reviewing pending or verified posts before approval or publication.
&nbsp;                        - **Seller:** Viewing or verifying their own product submission details.
&nbsp;                        - **Buyer:** Viewing detailed product information for browsing or purchasing decisions.
&nbsp;                    
&nbsp;                        **Security Notes:**
&nbsp;                        - Requires JWT authentication (`ROLE_BUYER`, `ROLE_SELLER`, or `ROLE_ADMIN`).
&nbsp;                        - Different roles may have access to different levels of detail based on internal authorization rules.
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @GetMapping(&quot;/{postProductId}/post-details&quot;)
&nbsp;    public ResponseEntity&lt;RestResponse&lt;PostProductResponse, Object&gt;&gt; viewPostProductDetail(
&nbsp;            @PathVariable Long postProductId
&nbsp;    ) throws Exception {
<b class="nc">&nbsp;        PostProduct postProduct = postProductServiceImpl.getPostProductById(postProductId);</b>
<b class="nc">&nbsp;        PostProductResponse responseData = postProductMapper.toDto(postProduct);</b>
<b class="nc">&nbsp;        RestResponse&lt;PostProductResponse, Object&gt; response = responseMapper.toDto(</b>
&nbsp;                true,
&nbsp;                &quot;POST PRODUCT DETAIL&quot;,
&nbsp;                responseData,
&nbsp;                null
&nbsp;        );
<b class="nc">&nbsp;        return ResponseEntity.status(HttpStatus.OK.value()).body(response);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @Operation(
&nbsp;            summary = &quot;Review and decide post product verification&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                        Allows an admin or moderator to approve or reject a seller&#39;s post product after manual review.
&nbsp;                        This endpoint records the decision, updates the product&#39;s verification status, 
&nbsp;                        and returns the updated product details.
&nbsp;                    
&nbsp;                        **Workflow:**
&nbsp;                        1. Admin sends a decision request containing the post product ID and decision details (approve or reject).
&nbsp;                        2. The system validates the product and applies the verification decision.
&nbsp;                        3. The updated post product entity is returned in the response.
&nbsp;                    
&nbsp;                        **Use cases:**
&nbsp;                        - Approving a verified product for listing.
&nbsp;                        - Rejecting a product submission with a reason or remark.
&nbsp;                        - Managing product moderation workflows.
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PostMapping(&quot;/review-post-product-decision&quot;)
&nbsp;    public ResponseEntity&lt;RestResponse&lt;PostProductResponse, Object&gt;&gt; reviewPostProductDecision(@Valid @RequestBody PostProductDecisionRequest request) throws Exception {
<b class="nc">&nbsp;        PostProduct result = postProductServiceImpl.checkPostProductVerification(request);</b>
<b class="nc">&nbsp;        PostProductResponse responseData = postProductMapper.toDto(result);</b>
<b class="nc">&nbsp;        RestResponse response = responseMapper.toDto(</b>
&nbsp;                true,
&nbsp;                &quot;POST HAS BEEN CHECKED&quot;,
&nbsp;                responseData,
&nbsp;                null
&nbsp;        );
<b class="nc">&nbsp;        return ResponseEntity.status(HttpStatus.OK.value()).body(response);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(
&nbsp;            summary = &quot;Block or unblock user account (buyer, seller, or admin)&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                    This endpoint allows an **administrator** to block or unblock a user account based on its type and ID.  
&nbsp;                    Supported account types include **buyer**, **seller**, and **admin**.
&nbsp;                    
&nbsp;                    The action performed (block or unblock) depends on the provided `activity` parameter.  
&nbsp;                    A message explaining the reason for the action can also be passed.
&nbsp;                    
&nbsp;                    - For **buyer** and **seller** accounts: the platform will call their respective services to perform the action.  
&nbsp;                    - For **admin** accounts: only a **super admin** can perform block or unblock operations.  
&nbsp;                    - If an invalid account type is provided, the system returns a **400 Bad Request** response.
&nbsp;                    
&nbsp;                    **Access Control:** Only users with the role `ROLE_ADMIN` are authorized to use this API.
&nbsp;                    
&nbsp;                    **Path Parameters:**
&nbsp;                    - `accountId` – The ID of the account to block or unblock.  
&nbsp;                    - `accountType` – The type of the account (`buyer`, `seller`, or `admin`).  
&nbsp;                    - `message` – A short explanation or note about the action (e.g., &quot;Violation of policy&quot;).  
&nbsp;                    - `activity` – Defines the action to perform: `&quot;block&quot;` or `&quot;unblock&quot;`.
&nbsp;                    
&nbsp;                    **Response:**
&nbsp;                    - **Success:** Returns a message confirming that the account was blocked or unblocked successfully.  
&nbsp;                    - **Failure:** Returns an error message describing the issue (e.g., invalid type, insufficient permission, or internal error).
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PreAuthorize((&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;))
&nbsp;    @PostMapping(&quot;/block-account/{accountId}/{accountType}/{message}/{activity}&quot;)
&nbsp;    public ResponseEntity&lt;?&gt; blockAccount(
&nbsp;            @PathVariable(name = &quot;accountId&quot;) long id,
&nbsp;            @PathVariable(name = &quot;accountType&quot;) String type,
&nbsp;            @PathVariable(name = &quot;message&quot;) String message,
&nbsp;            @PathVariable(name = &quot;activity&quot;) String activity
&nbsp;    ) {
&nbsp;        try {
&nbsp;            String successMessage;
&nbsp;            String actionText;
&nbsp;
&nbsp;            // ✅ Xác định hành động (Block hoặc Unblock)
<b class="nc">&nbsp;            if (&quot;block&quot;.equalsIgnoreCase(activity)) {</b>
<b class="nc">&nbsp;                actionText = &quot;BLOCK&quot;;</b>
<b class="nc">&nbsp;            } else if (&quot;unblock&quot;.equalsIgnoreCase(activity)) {</b>
<b class="nc">&nbsp;                actionText = &quot;UNBLOCK&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return ResponseEntity.badRequest().body(responseMapper.toDto(</b>
&nbsp;                        false,
&nbsp;                        &quot;INVALID ACTIVITY.&quot;,
&nbsp;                        null,
&nbsp;                        &quot;Activity must be either &#39;block&#39; or &#39;unblock&#39;.&quot;
&nbsp;                ));
&nbsp;            }
&nbsp;
&nbsp;            // ✅ Xử lý theo loại tài khoản
<b class="nc">&nbsp;            if (&quot;buyer&quot;.equalsIgnoreCase(type)) {</b>
<b class="nc">&nbsp;                buyerService.blockAccount(id, message, activity);</b>
<b class="nc">&nbsp;                successMessage = String.format(&quot;%s BUYER ACCOUNT SUCCESSFULLY.&quot;, actionText);</b>
<b class="nc">&nbsp;            } else if (&quot;seller&quot;.equalsIgnoreCase(type)) {</b>
<b class="nc">&nbsp;                sellerService.blockAccount(id, message, activity);</b>
<b class="nc">&nbsp;                successMessage = String.format(&quot;%s SELLER ACCOUNT SUCCESSFULLY.&quot;, actionText);</b>
<b class="nc">&nbsp;            } else if (&quot;admin&quot;.equalsIgnoreCase(type)) {</b>
<b class="nc">&nbsp;                Admin admin = adminService.getCurrentUser();</b>
<b class="nc">&nbsp;                if (!admin.isSuperAdmin()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;You do not have permission to block or unblock admin accounts.&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                adminService.blockAccount(id, message, activity);</b>
<b class="nc">&nbsp;                successMessage = String.format(&quot;%s ADMIN ACCOUNT SUCCESSFULLY.&quot;, actionText);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return ResponseEntity.badRequest().body(responseMapper.toDto(</b>
&nbsp;                        false,
&nbsp;                        &quot;INVALID ACCOUNT TYPE.&quot;,
&nbsp;                        null,
&nbsp;                        &quot;Type must be either &#39;buyer&#39;, &#39;seller&#39;, or &#39;admin&#39;.&quot;
&nbsp;                ));
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(</b>
&nbsp;                    true,
&nbsp;                    successMessage,
&nbsp;                    null,
&nbsp;                    null
&nbsp;            ));
&nbsp;
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            String actionText = activity.equalsIgnoreCase(&quot;unblock&quot;) ? &quot;UNBLOCK&quot; : &quot;BLOCK&quot;;</b>
&nbsp;
<b class="nc">&nbsp;            String errorMsg = switch (type.toLowerCase()) {</b>
<b class="nc">&nbsp;                case &quot;buyer&quot; -&gt; String.format(&quot;%s BUYER ACCOUNT FAILED.&quot;, actionText);</b>
<b class="nc">&nbsp;                case &quot;seller&quot; -&gt; String.format(&quot;%s SELLER ACCOUNT FAILED.&quot;, actionText);</b>
<b class="nc">&nbsp;                case &quot;admin&quot; -&gt; String.format(&quot;%s ADMIN ACCOUNT FAILED.&quot;, actionText);</b>
<b class="nc">&nbsp;                default -&gt; String.format(&quot;%s ACCOUNT FAILED.&quot;, actionText);</b>
&nbsp;            };
&nbsp;
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(</b>
&nbsp;                    false,
&nbsp;                    errorMsg,
&nbsp;                    null,
<b class="nc">&nbsp;                    e.getMessage()</b>
&nbsp;            ));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Operation(
&nbsp;            summary = &quot;Retrieve paginated list of admin accounts&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;                    This endpoint allows an **administrator** to retrieve a paginated list of all admin accounts in the system.  
&nbsp;                    It supports pagination parameters (`page`, `size`) to efficiently navigate large datasets.
&nbsp;                    
&nbsp;                    **Access Control:** Only users with the role `ROLE_ADMIN` are authorized to access this endpoint.
&nbsp;                    
&nbsp;                    **Query Parameters:**
&nbsp;                    - `page` – (optional) The page number to retrieve, default is `0`.
&nbsp;                    - `size` – (optional) The number of records per page, default is `10`.
&nbsp;                    
&nbsp;                    **Response:**
&nbsp;                    - On success: Returns a paginated list of `AdminResponse` objects containing admin details.
&nbsp;                    - On failure: Returns an error message and exception details if the retrieval fails.
&nbsp;                    &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @GetMapping(&quot;/list&quot;)
&nbsp;    public ResponseEntity&lt;?&gt; getAdminList(
&nbsp;            @RequestParam(name = &quot;page&quot;, defaultValue = &quot;0&quot;) int page,
&nbsp;            @RequestParam(name = &quot;size&quot;, defaultValue = &quot;10&quot;) int size
&nbsp;    ) {
&nbsp;        try {
<b class="nc">&nbsp;            Page&lt;Admin&gt; admins = adminService.getAdminList(page, size);</b>
<b class="nc">&nbsp;            Page&lt;AdminResponse&gt; responses = admins.map(adminMapper::toDto);</b>
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(</b>
&nbsp;                    true,
&nbsp;                    &quot;GET LIST ADMIN ACCOUNT SUCCESSFULLY.&quot;,
&nbsp;                    responses, null
&nbsp;            ));
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(</b>
&nbsp;                    true,
&nbsp;                    &quot;GET LIST ADMIN ACCOUNT FAILED.&quot;,
<b class="nc">&nbsp;                    null, e.getMessage()</b>
&nbsp;            ));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Operation(
&nbsp;            summary = &quot;Get admin profile by account ID&quot;,
&nbsp;            description = &quot;&quot;&quot;
&nbsp;        Retrieve the detailed profile information of an admin by their account ID.
&nbsp;        Only users with the role ROLE_ADMIN can access this endpoint.
&nbsp;        
&nbsp;        Example:
&nbsp;        GET /profile/5
&nbsp;        Requires Authorization header with a valid JWT token.
&nbsp;        &quot;&quot;&quot;
&nbsp;    )
&nbsp;    @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)
&nbsp;    @GetMapping(&quot;/profile/{accountId}&quot;)
&nbsp;    public ResponseEntity&lt;?&gt; getProfile(
&nbsp;            @PathVariable(name = &quot;accountId&quot;) long id
&nbsp;    ) {
&nbsp;        try {
<b class="nc">&nbsp;            Admin admin = adminService.getAdminProfile(id);</b>
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(</b>
&nbsp;                    true,
&nbsp;                    &quot;GET ADMIN PROFILE SUCCESSFULLY.&quot;,
<b class="nc">&nbsp;                    adminMapper.toDto(admin), null</b>
&nbsp;            ));
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            return ResponseEntity.ok(responseMapper.toDto(</b>
&nbsp;                    false,
&nbsp;                    &quot;GET ADMIN PROFILE FAILED.&quot;,
<b class="nc">&nbsp;                    null, e.getMessage()</b>
&nbsp;            ));
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-11-06 20:39</div>
</div>
</body>
</html>
